# Summary Statistic Calculation & Plotting Script
#  - this script computes summary statistics of the matrices created by 'rm_processor_updated_3.R'
#  - for each matrix generated by that script (except the observed data rm range) this script:
#     - computes min, q1, median, q3, max, and standard deviation values
#     - from the aggregate of the 34 model matrices for:
#        - model rm range, observed - model difference, and model bias factor
#  - for each summary stat four panel figures are plotted in the same layout as the output of 'rm_processor_updated_3.R'


library(abind)
library(terra)
library(jpeg)

# visualizers
source("scripts/visualizers/rm_range_visualizer.R")
source("scripts/visualizers/difference_visualizer.R")
source("scripts/visualizers/bias_factor_visualizer.R")

##################################
# FUNCTIONS

# Function to calculate minimum across model statistics
#  - takes input list of matrices
#  - abind matrices into array by type (rm range, norm diff, bias factor)
#  - apply min across arrays
#  - return collapsed matrix for each type
calculate_min <- function(results) {

  model_keys <- names(results)[grepl("_rm_range$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_rm_range$", "", model_keys)
  
  # Initialize lists to store arrays
  rm_range_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  rm_range_dimnames <- dimnames(results[[paste0(first_model, "_historical_rm_range")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Running mean range
    rm_range_mat <- results[[paste0(model_name, "_historical_rm_range")]]
    rm_range_arrays[[length(rm_range_arrays) + 1]] <- rm_range_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  rm_range_array <- abind(rm_range_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate minimum across models
  # Use apply() with custom function to handle NA/Inf values
  rm_range_min <- apply(rm_range_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      return(min(x, na.rm = TRUE))
    }
  })
  
  difference_min <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      return(min(x, na.rm = TRUE))
    }
  })
  
  bias_factor_min <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      return(min(x, na.rm = TRUE))
    }
  })
  
  # Preserve dims
  dimnames(rm_range_min) <- rm_range_dimnames
  dimnames(difference_min) <- difference_dimnames
  dimnames(bias_factor_min) <- bias_factor_dimnames
  
  return(list(
    min_rm_range = rm_range_min,
    min_difference = difference_min,
    min_bias_factor = bias_factor_min
  ))
}

# Function to calculate first quartile across models
#  - takes input list of matrices
#  - abind matrices into array by type (rm range, norm diff, bias factor)
#  - apply q1 across arrays
#  - return collapsed matrix for each type
calculate_q1 <- function(results) {

  model_keys <- names(results)[grepl("_rm_range$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_rm_range$", "", model_keys)
  
  # Initialize lists to store arrays
  rm_range_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  rm_range_dimnames <- dimnames(results[[paste0(first_model, "_historical_rm_range")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Running mean range
    rm_range_mat <- results[[paste0(model_name, "_historical_rm_range")]]
    rm_range_arrays[[length(rm_range_arrays) + 1]] <- rm_range_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  rm_range_array <- abind(rm_range_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate first quartile across models
  # Use apply() with custom function to handle NA/Inf values
  rm_range_q1 <- apply(rm_range_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(quantile(valid_x, 0.25))
    }
  })
  
  difference_q1 <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(quantile(valid_x, 0.25))
    }
  })
  
  bias_factor_q1 <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(quantile(valid_x, 0.25))
    }
  })
  
  # Preserve dims
  dimnames(rm_range_q1) <- rm_range_dimnames
  dimnames(difference_q1) <- difference_dimnames
  dimnames(bias_factor_q1) <- bias_factor_dimnames
  
  return(list(
    q1_rm_range = rm_range_q1,
    q1_difference = difference_q1,
    q1_bias_factor = bias_factor_q1
  ))
}

# Function to calculate median across models
#  - takes input list of matrices
#  - abind matrices into array by type (rm range, norm diff, bias factor)
#  - apply median across arrays
#  - return collapsed matrix for each type
calculate_median <- function(results) {

  model_keys <- names(results)[grepl("_rm_range$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_rm_range$", "", model_keys)
  
  # Initialize lists to store arrays
  rm_range_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  rm_range_dimnames <- dimnames(results[[paste0(first_model, "_historical_rm_range")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Running mean range
    rm_range_mat <- results[[paste0(model_name, "_historical_rm_range")]]
    rm_range_arrays[[length(rm_range_arrays) + 1]] <- rm_range_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  rm_range_array <- abind(rm_range_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate median across models
  # Use apply() with custom function to handle NA/Inf values
  rm_range_median <- apply(rm_range_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(median(valid_x))
    }
  })
  
  difference_median <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(median(valid_x))
    }
  })
  
  bias_factor_median <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(median(valid_x))
    }
  })
  
  # Preserve dims
  dimnames(rm_range_median) <- rm_range_dimnames
  dimnames(difference_median) <- difference_dimnames
  dimnames(bias_factor_median) <- bias_factor_dimnames
  
  return(list(
    median_rm_range = rm_range_median,
    median_difference = difference_median,
    median_bias_factor = bias_factor_median
  ))
}

# Function to calculate third quartile across models
#  - takes input list of matrices
#  - abind matrices into array by type (rm range, norm diff, bias factor)
#  - apply q3 across arrays
#  - return collapsed matrix for each type
calculate_q3 <- function(results) {

  model_keys <- names(results)[grepl("_rm_range$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_rm_range$", "", model_keys)
  
  # Initialize lists to store arrays
  rm_range_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  rm_range_dimnames <- dimnames(results[[paste0(first_model, "_historical_rm_range")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Running mean range
    rm_range_mat <- results[[paste0(model_name, "_historical_rm_range")]]
    rm_range_arrays[[length(rm_range_arrays) + 1]] <- rm_range_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  rm_range_array <- abind(rm_range_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate third quartile across models
  # Use apply() with custom function to handle NA/Inf values
  rm_range_q3 <- apply(rm_range_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(quantile(valid_x, 0.75))
    }
  })
  
  difference_q3 <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(quantile(valid_x, 0.75))
    }
  })
  
  bias_factor_q3 <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(quantile(valid_x, 0.75))
    }
  })
  
  # Preserve dims
  dimnames(rm_range_q3) <- rm_range_dimnames
  dimnames(difference_q3) <- difference_dimnames
  dimnames(bias_factor_q3) <- bias_factor_dimnames
  
  return(list(
    q3_rm_range = rm_range_q3,
    q3_difference = difference_q3,
    q3_bias_factor = bias_factor_q3
  ))
}

# Function to calculate maximum across models
#  - takes input list of matrices
#  - abind matrices into array by type (rm range, norm diff, bias factor)
#  - apply max across arrays
#  - return collapsed matrix for each type
calculate_max <- function(results) {

  model_keys <- names(results)[grepl("_rm_range$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_rm_range$", "", model_keys)
  
  # Initialize lists to store arrays
  rm_range_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  rm_range_dimnames <- dimnames(results[[paste0(first_model, "_historical_rm_range")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Running mean range
    rm_range_mat <- results[[paste0(model_name, "_historical_rm_range")]]
    rm_range_arrays[[length(rm_range_arrays) + 1]] <- rm_range_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  rm_range_array <- abind(rm_range_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate maximum across models
  # Use apply() with custom function to handle NA/Inf values
  rm_range_max <- apply(rm_range_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      return(max(x, na.rm = TRUE))
    }
  })
  
  difference_max <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      return(max(x, na.rm = TRUE))
    }
  })
  
  bias_factor_max <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      return(max(x, na.rm = TRUE))
    }
  })
  
  # Preserve dims
  dimnames(rm_range_max) <- rm_range_dimnames
  dimnames(difference_max) <- difference_dimnames
  dimnames(bias_factor_max) <- bias_factor_dimnames
  
  # Return results
  return(list(
    max_rm_range = rm_range_max,
    max_difference = difference_max,
    max_bias_factor = bias_factor_max
  ))
}

# Function to calculate mean across models
#  - takes input list of matrices
#  - abind matrices into array by type (rm range, norm diff, bias factor)
#  - apply mean across arrays
#  - return collapsed matrix for each type
calculate_mean <- function(results) {

  model_keys <- names(results)[grepl("_rm_range$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_rm_range$", "", model_keys)
  
  # Initialize lists to store arrays
  rm_range_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  rm_range_dimnames <- dimnames(results[[paste0(first_model, "_historical_rm_range")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Running mean range
    rm_range_mat <- results[[paste0(model_name, "_historical_rm_range")]]
    rm_range_arrays[[length(rm_range_arrays) + 1]] <- rm_range_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  rm_range_array <- abind(rm_range_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate mean across models
  # Use apply() with custom function to handle NA/Inf values
  rm_range_mean <- apply(rm_range_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(mean(valid_x))
    }
  })
  
  difference_mean <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(mean(valid_x))
    }
  })
  
  bias_factor_mean <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(mean(valid_x))
    }
  })
  
  # Preserve dims
  dimnames(rm_range_mean) <- rm_range_dimnames
  dimnames(difference_mean) <- difference_dimnames
  dimnames(bias_factor_mean) <- bias_factor_dimnames
  
  return(list(
    mean_rm_range = rm_range_mean,
    mean_difference = difference_mean,
    mean_bias_factor = bias_factor_mean
  ))
}

# Function to calculate standard deviation across models
#  - takes input list of matrices
#  - abind matrices into array by type (rm range, norm diff, bias factor)
#  - apply stdev across arrays
#  - return collapsed matrix for each type
calculate_sd <- function(results) {

  model_keys <- names(results)[grepl("_rm_range$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_rm_range$", "", model_keys)
  
  # Initialize lists to store arrays
  rm_range_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  rm_range_dimnames <- dimnames(results[[paste0(first_model, "_historical_rm_range")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Running mean range
    rm_range_mat <- results[[paste0(model_name, "_historical_rm_range")]]
    rm_range_arrays[[length(rm_range_arrays) + 1]] <- rm_range_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  rm_range_array <- abind(rm_range_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate standard deviation across models
  # Use apply() with custom function to handle NA/Inf values
  rm_range_sd <- apply(rm_range_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) <= 1) return(NA)
      return(sd(valid_x))
    }
  })
  
  difference_sd <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) <= 1) return(NA)
      return(sd(valid_x))
    }
  })
  
  bias_factor_sd <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) <= 1) return(NA)
      return(sd(valid_x))
    }
  })
  
  # Preserve dims
  dimnames(rm_range_sd) <- rm_range_dimnames
  dimnames(difference_sd) <- difference_dimnames
  dimnames(bias_factor_sd) <- bias_factor_dimnames
  
  return(list(
    sd_rm_range = rm_range_sd,
    sd_difference = difference_sd,
    sd_bias_factor = bias_factor_sd
  ))
}

# Function to create summary statistic plots with histograms
#   - takes the list of summary stat matrices as input
#   - takes the base list as input (extracts obs matrix)
#   - iterates through the list and creates 4 panel plots with inset histograms
create_summary_stat_plots_with_histograms <- function(results, summary_stats) {

  # find the overall range for running mean values to use consistent scale
  all_rm_ranges <- c(results$observed_rm_range)
  model_keys <- names(results)[grepl("_rm_range$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_rm_range$", "", model_keys)
  
  for (model_name in model_names) {
    model_rm_data <- results[[paste0(model_name, "_historical_rm_range")]]
    all_rm_ranges <- c(all_rm_ranges, model_rm_data)
  }
  min_val <- min(all_rm_ranges, na.rm = TRUE)
  max_val <- max(all_rm_ranges, na.rm = TRUE)
  range_buffer <- (max_val - min_val) * 0.001
  rm_range_min <- min_val - range_buffer
  rm_range_max <- max_val + range_buffer
  
  # Set fixed scales for difference and bias factor
  diff_min <- -1
  diff_max <- 1.5
  bias_min <- 0
  bias_max <- 9
  
  if (!dir.exists("figures/rm_range_summary_stats_figures")) {
    dir.create("figures/rm_range_summary_stats_figures", recursive = TRUE)
  }
  
  # Helper function to create custom histogram axes using text and segments
  create_custom_histogram_axis <- function(x_min, x_max, plot_type = "rm_range") {

    if (plot_type == "rm_range") {
      # For RM Range plots (observed and model)
      tick_positions <- c(0.5, 1.0, 1.5)
      tick_labels <- c("0.5", "1.0", "1.5")
    } else if (plot_type == "difference") {
      # For normalized difference plot
      tick_positions <- c(-1, -0.5, 0, 0.5, 1.0, 1.5)
      tick_labels <- c("-1", "-0.5", "0", "0.5", "1.0", "1.5")
    } else if (plot_type == "bias") {
      # For bias factor plot
      tick_positions <- c(0, 2, 4, 6, 8)
      tick_labels <- c("0", "2", "4", "6", "8")
    }
    
    par(xpd = TRUE)
    
    usr <- par("usr")
    
    # position relative to the plot height
    plot_height <- usr[4] - usr[3]
    y_bottom <- usr[3] - 0.02 * plot_height  # adjust clearance below plot
    y_tick_length <- 0.03 * plot_height      # Length of tick marks
    
    # Use a fixed distance below the ticks rather than relative to the plot
    text_y_pos <- y_bottom - 0.08 * plot_height  
    
    # Draw segments for tick marks
    for (i in 1:length(tick_positions)) {
      segments(
        x0 = tick_positions[i], 
        y0 = y_bottom, 
        x1 = tick_positions[i], 
        y1 = y_bottom + y_tick_length, 
        lwd = 1.2
      )
    }
    
    # Add text labels
    for (i in 1:length(tick_positions)) {
      text(
        x = tick_positions[i], 
        y = text_y_pos, 
        labels = tick_labels[i],
        cex = 0.5,
        adj = c(0.5, 1),
        font = 2
      )
    }
    
    par(xpd = FALSE)
  }
  
  # Helper function to position a grid plot in its quadrant
  position_grid_plot <- function(quadrant) {
    # Define the dimensions for each quadrant
    # Format: c(left, right, bottom, top)
    quadrant_dims <- list(
      "1" = c(0.0, 0.5, 0.5, 1.0),  # Top-left
      "2" = c(0.5, 1.0, 0.5, 1.0),  # Top-right
      "3" = c(0.0, 0.5, 0.0, 0.5),  # Bottom-left
      "4" = c(0.5, 1.0, 0.0, 0.5)   # Bottom-right
    )
    
    # Set the figure region for this quadrant
    par(fig = quadrant_dims[[as.character(quadrant)]], mar = c(4, 4, 3, 2))
    
    # Only use new=TRUE for quadrants after the first
    if (quadrant > 1) {
      par(new = TRUE)
    }
  }
  
  # Helper function to position a histogram inset in each plot
  position_histogram_inset <- function(quadrant) {
    # Define the base inset dimensions
    inset_width <- 0.165
    inset_height <- 0.32  # increase to provide space for labels
    
    # Base coordinates for each quadrant
    base_coords <- list(
      "1" = c(0.0, 0.5, 0.5, 1.0),  # Top-left quadrant
      "2" = c(0.5, 1.0, 0.5, 1.0),  # Top-right quadrant
      "3" = c(0.0, 0.5, 0.0, 0.5),  # Bottom-left quadrant
      "4" = c(0.5, 1.0, 0.0, 0.5)   # Bottom-right quadrant
    )
    
    base <- base_coords[[as.character(quadrant)]]
    
    # Position the inset in the upper-left corner
    inset_coords <- c(
      base[1] + 0.04,                # increase to move right
      base[1] + 0.12 + inset_width,  # match left edge
      base[3] + (base[4] - base[3]) * 0.58,  # lower shifts down
      base[4] - 0.08                 # smaller values = taller plot
    )
  
    par(fig = inset_coords, new = TRUE, mar = c(1.5, 0.1, 0.1, 0.1))
  }
  
  # Process each summary statistic
  for (stat_name in names(summary_stats)) {

    if (!grepl("_rm_range$|_difference$|_bias_factor$", stat_name)) {
      next
    }
    
    base_stat_type <- gsub("_rm_range$|_difference$|_bias_factor$", "", stat_name)
    
    stat_title <- switch(base_stat_type,
                         "min" = "Minimum",
                         "q1" = "First Quartile",
                         "median" = "Median",
                         "q3" = "Third Quartile",
                         "max" = "Maximum",
                         "mean" = "Mean",
                         "sd" = "Standard Deviation",
                         base_stat_type)
    
    observed_data <- results$observed_rm_range
    
    # Find the statistic types for this base type
    rm_range_stat_name <- paste0(base_stat_type, "_rm_range")
    difference_stat_name <- paste0(base_stat_type, "_difference")
    bias_factor_stat_name <- paste0(base_stat_type, "_bias_factor")
    
    # Get the summary statistics
    rm_range_data <- summary_stats[[rm_range_stat_name]]
    difference_data <- summary_stats[[difference_stat_name]]
    bias_factor_data <- summary_stats[[bias_factor_stat_name]]
    
    output_filename <- paste0("figures/rm_range_summary_stats_figures/rm_range_", base_stat_type, "_summary_stats.jpg")
    jpeg(output_filename, width = 10, height = 8, units = "in", res = 300)
    
    # 1. Observed RM Range grid (Quadrant 1: Top-left)
    position_grid_plot(1)
    rm_range_visualizer(
      observed_data, 
      paste0("Observed RM Range"),
      min_max_range = c(rm_range_min, rm_range_max)
    )
    
    # Add inset histogram for observed data
    observed_flat <- as.vector(observed_data)
    observed_flat <- observed_flat[!is.na(observed_flat)]
    position_histogram_inset(1)
    
    hist(observed_flat, 
         main = "", 
         xlab = "", 
         ylab = "",
         col = "lightblue", 
         border = "black",
         xlim = c(rm_range_min, rm_range_max),
         breaks = 20,
         axes = FALSE)
    
    create_custom_histogram_axis(rm_range_min, rm_range_max, plot_type = "rm_range")
    
    # 2. Model RM Range Statistic grid (Quadrant 2: Top-right)
    position_grid_plot(2)
    rm_range_visualizer(
      rm_range_data, 
      paste0(stat_title, " of Model RM Range"),
      min_max_range = c(rm_range_min, rm_range_max)
    )
    
    # Add inset histogram for model data
    model_flat <- as.vector(rm_range_data)
    model_flat <- model_flat[!is.na(model_flat)]
    position_histogram_inset(2)
    
    hist(model_flat, 
         main = "", 
         xlab = "", 
         ylab = "",
         col = "lightblue", 
         border = "black",
         xlim = c(rm_range_min, rm_range_max),
         breaks = 20,
         axes = FALSE)
    
    create_custom_histogram_axis(rm_range_min, rm_range_max, plot_type = "rm_range")
    
    # 3. Normalized difference statistic grid (Quadrant 3: Bottom-left)
    position_grid_plot(3)
    difference_visualizer(
      difference_data, 
      paste0(stat_title, " of Normalized Difference")
    )
    
    # Add inset histogram for difference data
    diff_flat <- as.vector(difference_data)
    diff_flat <- diff_flat[!is.na(diff_flat)]
    position_histogram_inset(3)
    
    hist(diff_flat, 
         main = "", 
         xlab = "", 
         ylab = "",
         col = "lightblue",
         border = "black",
         xlim = c(diff_min, diff_max),
         breaks = 20,
         axes = FALSE)
    
    create_custom_histogram_axis(diff_min, diff_max, plot_type = "difference")
    
    # 4. Bias factor statistic grid (Quadrant 4: Bottom-right)
    position_grid_plot(4)
    bias_factor_visualizer(
      bias_factor_data, 
      paste0(stat_title, " of Bias Factor")
    )
    
    # Add inset histogram for bias factor data
    bias_flat <- as.vector(bias_factor_data)
    bias_flat <- bias_flat[!is.na(bias_flat)]
    position_histogram_inset(4)
    
    hist(bias_flat, 
         main = "", 
         xlab = "", 
         ylab = "",
         col = "lightblue",
         border = "black",
         xlim = c(bias_min, bias_max),
         breaks = 20,
         axes = FALSE)
    
    create_custom_histogram_axis(bias_min, bias_max, plot_type = "bias")
    
    dev.off()
    cat("Saved visualization for", stat_title, "to", output_filename, "\n")
  }
}

##################################
# MAIN EXECUTION

load("rdata/rm_derived_matrices_list.RData", envir = .GlobalEnv)

# Calculate all summary statistics and combine into a single list
summary_stats <- c(
  calculate_min(rm_derived_matrices),
  calculate_q1(rm_derived_matrices),
  calculate_median(rm_derived_matrices),
  calculate_q3(rm_derived_matrices),
  calculate_max(rm_derived_matrices),
  calculate_mean(rm_derived_matrices),
  calculate_sd(rm_derived_matrices)
)

create_summary_stat_plots_with_histograms(rm_derived_matrices, summary_stats)
