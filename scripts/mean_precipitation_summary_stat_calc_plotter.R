# Summary Statistic Calculation & Plotting Script for Mean Precipitation
#  - this script computes summary statistics of the matrices created by the mean precipitation script
#  - for each matrix generated by that script (except the observed data mean) this script:
#     - computes min, q1, median, q3, max, and standard deviation values
#     - from the aggregate of the 34 model matrices for:
#        - model mean precipitation, observed - model difference, and model bias factor
#  - for each summary stat four panel figures are plotted in the same layout as the output

library(abind)
library(terra)
library(jpeg)

# visualizers
source("scripts/visualizers/aggregate_plot_visualizer.R")
source("scripts/visualizers/difference_visualizer.R")
source("scripts/visualizers/bias_factor_visualizer.R")

##################################
# FUNCTIONS

# Function to calculate minimum across model statistics
#  - takes input list of matrices
#  - abind matrices into array by type (mean precip, norm diff, bias factor)
#  - apply min across arrays
#  - return collapsed matrix for each type
calculate_min <- function(results) {
  # Get model names (excluding observed data)
  model_keys <- names(results)[grepl("_mean_precipitation$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_mean_precipitation$", "", model_keys)
  
  # Initialize lists to store arrays
  mean_precip_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  mean_precip_dimnames <- dimnames(results[[paste0(first_model, "_historical_mean_precipitation")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Mean precipitation
    mean_precip_mat <- results[[paste0(model_name, "_historical_mean_precipitation")]]
    mean_precip_arrays[[length(mean_precip_arrays) + 1]] <- mean_precip_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  mean_precip_array <- abind(mean_precip_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate minimum across models handling na/inf
  mean_precip_min <- apply(mean_precip_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      return(min(x, na.rm = TRUE))
    }
  })
  
  difference_min <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      return(min(x, na.rm = TRUE))
    }
  })
  
  bias_factor_min <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      return(min(x, na.rm = TRUE))
    }
  })
  
  # Preserve dims
  dimnames(mean_precip_min) <- mean_precip_dimnames
  dimnames(difference_min) <- difference_dimnames
  dimnames(bias_factor_min) <- bias_factor_dimnames
  
  return(list(
    min_mean_precipitation = mean_precip_min,
    min_difference = difference_min,
    min_bias_factor = bias_factor_min
  ))
}

# Function to calculate first quartile across models
#  - takes input list of matrices
#  - abind matrices into array by type (mean precip, norm diff, bias factor)
#  - apply q1 across arrays
#  - return collapsed matrix for each type
calculate_q1 <- function(results) {
  # Get model names (excluding observed data)
  model_keys <- names(results)[grepl("_mean_precipitation$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_mean_precipitation$", "", model_keys)
  
  # Initialize lists to store arrays
  mean_precip_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  mean_precip_dimnames <- dimnames(results[[paste0(first_model, "_historical_mean_precipitation")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Mean precipitation
    mean_precip_mat <- results[[paste0(model_name, "_historical_mean_precipitation")]]
    mean_precip_arrays[[length(mean_precip_arrays) + 1]] <- mean_precip_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  mean_precip_array <- abind(mean_precip_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate first quartile across models with na/inf handling
  mean_precip_q1 <- apply(mean_precip_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(quantile(valid_x, 0.25))
    }
  })
  
  difference_q1 <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(quantile(valid_x, 0.25))
    }
  })
  
  bias_factor_q1 <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(quantile(valid_x, 0.25))
    }
  })
  
  # Preserve dims
  dimnames(mean_precip_q1) <- mean_precip_dimnames
  dimnames(difference_q1) <- difference_dimnames
  dimnames(bias_factor_q1) <- bias_factor_dimnames
  
  return(list(
    q1_mean_precipitation = mean_precip_q1,
    q1_difference = difference_q1,
    q1_bias_factor = bias_factor_q1
  ))
}

# Function to calculate median across models
#  - takes input list of matrices
#  - abind matrices into array by type (mean precip, norm diff, bias factor)
#  - apply median across arrays
#  - return collapsed matrix for each type
calculate_median <- function(results) {
  # Get model names (excluding observed data)
  model_keys <- names(results)[grepl("_mean_precipitation$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_mean_precipitation$", "", model_keys)
  
  # Initialize lists to store arrays
  mean_precip_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  mean_precip_dimnames <- dimnames(results[[paste0(first_model, "_historical_mean_precipitation")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Mean precipitation
    mean_precip_mat <- results[[paste0(model_name, "_historical_mean_precipitation")]]
    mean_precip_arrays[[length(mean_precip_arrays) + 1]] <- mean_precip_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  mean_precip_array <- abind(mean_precip_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate median across models with na/inf handling
  mean_precip_median <- apply(mean_precip_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(median(valid_x))
    }
  })
  
  difference_median <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(median(valid_x))
    }
  })
  
  bias_factor_median <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(median(valid_x))
    }
  })
  
  # Preserve dimnames
  dimnames(mean_precip_median) <- mean_precip_dimnames
  dimnames(difference_median) <- difference_dimnames
  dimnames(bias_factor_median) <- bias_factor_dimnames
  
  return(list(
    median_mean_precipitation = mean_precip_median,
    median_difference = difference_median,
    median_bias_factor = bias_factor_median
  ))
}

# Function to calculate third quartile across models
#  - takes input list of matrices
#  - abind matrices into array by type (mean precip, norm diff, bias factor)
#  - apply q3 across arrays
#  - return collapsed matrix for each type
calculate_q3 <- function(results) {
  # Get model names (excluding observed data)
  model_keys <- names(results)[grepl("_mean_precipitation$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_mean_precipitation$", "", model_keys)
  
  # Initialize lists to store arrays
  mean_precip_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  mean_precip_dimnames <- dimnames(results[[paste0(first_model, "_historical_mean_precipitation")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Mean precipitation
    mean_precip_mat <- results[[paste0(model_name, "_historical_mean_precipitation")]]
    mean_precip_arrays[[length(mean_precip_arrays) + 1]] <- mean_precip_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  mean_precip_array <- abind(mean_precip_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate third quartile across models and handle na/inf
  mean_precip_q3 <- apply(mean_precip_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(quantile(valid_x, 0.75))
    }
  })
  
  difference_q3 <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(quantile(valid_x, 0.75))
    }
  })
  
  bias_factor_q3 <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(quantile(valid_x, 0.75))
    }
  })
  
  # Preserve dims
  dimnames(mean_precip_q3) <- mean_precip_dimnames
  dimnames(difference_q3) <- difference_dimnames
  dimnames(bias_factor_q3) <- bias_factor_dimnames
  
  return(list(
    q3_mean_precipitation = mean_precip_q3,
    q3_difference = difference_q3,
    q3_bias_factor = bias_factor_q3
  ))
}

# Function to calculate maximum across models
#  - takes input list of matrices
#  - abind matrices into array by type (mean precip, norm diff, bias factor)
#  - apply max across arrays
#  - return collapsed matrix for each type
calculate_max <- function(results) {
  # Get model names (excluding observed data)
  model_keys <- names(results)[grepl("_mean_precipitation$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_mean_precipitation$", "", model_keys)
  
  # Initialize lists to store arrays
  mean_precip_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  mean_precip_dimnames <- dimnames(results[[paste0(first_model, "_historical_mean_precipitation")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Mean precipitation
    mean_precip_mat <- results[[paste0(model_name, "_historical_mean_precipitation")]]
    mean_precip_arrays[[length(mean_precip_arrays) + 1]] <- mean_precip_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  mean_precip_array <- abind(mean_precip_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate maximum across models and handle na/infs
  mean_precip_max <- apply(mean_precip_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      return(max(x, na.rm = TRUE))
    }
  })
  
  difference_max <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      return(max(x, na.rm = TRUE))
    }
  })
  
  bias_factor_max <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      return(max(x, na.rm = TRUE))
    }
  })
  
  # Preserve dimnames
  dimnames(mean_precip_max) <- mean_precip_dimnames
  dimnames(difference_max) <- difference_dimnames
  dimnames(bias_factor_max) <- bias_factor_dimnames
  
  return(list(
    max_mean_precipitation = mean_precip_max,
    max_difference = difference_max,
    max_bias_factor = bias_factor_max
  ))
}

# Function to calculate mean across models
#  - takes input list of matrices
#  - abind matrices into array by type (mean precip, norm diff, bias factor)
#  - apply mean across arrays
#  - return collapsed matrix for each type
calculate_mean <- function(results) {
  # Get model names (excluding observed data)
  model_keys <- names(results)[grepl("_mean_precipitation$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_mean_precipitation$", "", model_keys)
  
  # Initialize lists to store arrays
  mean_precip_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  mean_precip_dimnames <- dimnames(results[[paste0(first_model, "_historical_mean_precipitation")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Mean precipitation
    mean_precip_mat <- results[[paste0(model_name, "_historical_mean_precipitation")]]
    mean_precip_arrays[[length(mean_precip_arrays) + 1]] <- mean_precip_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  mean_precip_array <- abind(mean_precip_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate mean across models handling na/infs
  mean_precip_mean <- apply(mean_precip_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(mean(valid_x))
    }
  })
  
  difference_mean <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(mean(valid_x))
    }
  })
  
  bias_factor_mean <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) == 0) return(NA)
      return(mean(valid_x))
    }
  })
  
  # Preserve dims
  dimnames(mean_precip_mean) <- mean_precip_dimnames
  dimnames(difference_mean) <- difference_dimnames
  dimnames(bias_factor_mean) <- bias_factor_dimnames

  return(list(
    mean_mean_precipitation = mean_precip_mean,
    mean_difference = difference_mean,
    mean_bias_factor = bias_factor_mean
  ))
}

# Function to calculate standard deviation across models
#  - takes input list of matrices
#  - abind matrices into array by type (mean precip, norm diff, bias factor)
#  - apply stdev across arrays
#  - return collapsed matrix for each type
calculate_sd <- function(results) {
  # Get model names (excluding observed data)
  model_keys <- names(results)[grepl("_mean_precipitation$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_mean_precipitation$", "", model_keys)
  
  # Initialize lists to store arrays
  mean_precip_arrays <- list()
  difference_arrays <- list()
  bias_factor_arrays <- list()
  
  # Store dimension names from the first model to ensure preservation
  first_model <- model_names[1]
  mean_precip_dimnames <- dimnames(results[[paste0(first_model, "_historical_mean_precipitation")]])
  difference_dimnames <- dimnames(results[[paste0(first_model, "_historical_difference")]])
  bias_factor_dimnames <- dimnames(results[[paste0(first_model, "_historical_bias_factor")]])
  
  # Collect matrices into lists
  for (model_name in model_names) {
    # Mean precipitation
    mean_precip_mat <- results[[paste0(model_name, "_historical_mean_precipitation")]]
    mean_precip_arrays[[length(mean_precip_arrays) + 1]] <- mean_precip_mat
    
    # Difference
    diff_mat <- results[[paste0(model_name, "_historical_difference")]]
    difference_arrays[[length(difference_arrays) + 1]] <- diff_mat
    
    # Bias factor
    bias_mat <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_factor_arrays[[length(bias_factor_arrays) + 1]] <- bias_mat
  }
  
  # Convert lists to 3D arrays
  mean_precip_array <- abind(mean_precip_arrays, along = 3)
  difference_array <- abind(difference_arrays, along = 3)
  bias_factor_array <- abind(bias_factor_arrays, along = 3)
  
  # Calculate standard deviation across models with na/inf handling
  mean_precip_sd <- apply(mean_precip_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) <= 1) return(NA)
      return(sd(valid_x))
    }
  })
  
  difference_sd <- apply(difference_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) <= 1) return(NA)
      return(sd(valid_x))
    }
  })
  
  bias_factor_sd <- apply(bias_factor_array, c(1, 2), function(x) {
    if(all(is.na(x) | is.infinite(x))) {
      return(NA)
    } else {
      valid_x <- x[!is.na(x) & !is.infinite(x)]
      if(length(valid_x) <= 1) return(NA)
      return(sd(valid_x))
    }
  })
  
  # Preserve dims
  dimnames(mean_precip_sd) <- mean_precip_dimnames
  dimnames(difference_sd) <- difference_dimnames
  dimnames(bias_factor_sd) <- bias_factor_dimnames
  
  return(list(
    sd_mean_precipitation = mean_precip_sd,
    sd_difference = difference_sd,
    sd_bias_factor = bias_factor_sd
  ))
}

# Function to create summary statistic plots with histograms
#   - takes the list of summary stat matrices as input
#   - takes the base list as input (extracts obs matrix)
#   - iterates through the list and creates 4 panel plots with inset histograms
create_summary_stat_plots_with_histograms <- function(results, summary_stats) {
  # Calculate appropriate scales for all plots based on data
  # Find the overall range for mean precipitation values
  all_mean_values <- c(results$observed_mean_precipitation)
  model_keys <- names(results)[grepl("_mean_precipitation$", names(results)) & !grepl("^observed", names(results))]
  model_names <- gsub("_historical_mean_precipitation$", "", model_keys)
  
  for (model_name in model_names) {
    model_mean_data <- results[[paste0(model_name, "_historical_mean_precipitation")]]
    all_mean_values <- c(all_mean_values, model_mean_data)
  }
  
  # Calculate min and max with buffer
  min_val <- min(all_mean_values, na.rm = TRUE)
  max_val <- max(all_mean_values, na.rm = TRUE)
  range_buffer <- (max_val - min_val) * 0.001
  mean_min <- min_val - range_buffer
  mean_max <- max_val + range_buffer
  
  # Collect all difference and bias factor values
  all_diff_values <- c()
  all_bias_values <- c()
  
  # Sample each model's difference and bias factor matrices
  for (model_name in model_names) {
    # Get difference data
    diff_data <- results[[paste0(model_name, "_historical_difference")]]
    diff_flat <- as.vector(diff_data)
    diff_flat <- diff_flat[!is.na(diff_flat)]
    all_diff_values <- c(all_diff_values, diff_flat)
    
    # Get bias factor data
    bias_data <- results[[paste0(model_name, "_historical_bias_factor")]]
    bias_flat <- as.vector(bias_data)
    bias_flat <- bias_flat[!is.na(bias_flat)]
    all_bias_values <- c(all_bias_values, bias_flat)
  }
  
  # Calculate min and max for difference with 5% buffer on each end
  diff_range <- max(all_diff_values, na.rm = TRUE) - min(all_diff_values, na.rm = TRUE)
  diff_buffer <- diff_range * 0.05
  diff_min <- min(all_diff_values, na.rm = TRUE) - diff_buffer
  diff_max <- max(all_diff_values, na.rm = TRUE) + diff_buffer
  
  # For bias factor, ensure the minimum is always >= 0
  bias_range <- max(all_bias_values, na.rm = TRUE) - min(all_bias_values, na.rm = TRUE)
  bias_buffer <- bias_range * 0.05
  bias_min <- max(0, min(all_bias_values, na.rm = TRUE) - bias_buffer)
  bias_max <- max(all_bias_values, na.rm = TRUE) + bias_buffer
  
  # Create output directory if it doesn't exist
  if (!dir.exists("figures/mean_precipitation_summary_stats")) {
    dir.create("figures/mean_precipitation_summary_stats", recursive = TRUE)
  }
  
  # Helper function to create custom histogram axes using text and segments
  create_custom_histogram_axis <- function(x_min, x_max, plot_type = "mean_precip") {
    # Set specific tick positions based on plot type
    if (plot_type == "mean_precip") {
      tick_count <- 5
      tick_positions <- seq(x_min, x_max, length.out = tick_count)
      if (max(tick_positions) > 10) {
        tick_labels <- as.character(round(tick_positions, 1))
      } else {
        tick_labels <- as.character(round(tick_positions, 2))
      }
    } else if (plot_type == "difference") {
      tick_count <- 5
      tick_positions <- seq(diff_min, diff_max, length.out = tick_count)
      tick_labels <- as.character(round(tick_positions, 2))
    } else if (plot_type == "bias") {
      tick_count <- 5
      tick_positions <- seq(bias_min, bias_max, length.out = tick_count)
      if (bias_max > 10) {
        tick_labels <- as.character(round(tick_positions, 1))
      } else {
        tick_labels <- as.character(round(tick_positions, 2))
      }
    }
    
    par(xpd = TRUE)
    
    # get the plot coords so drawing/position can be semi-automated
    usr <- par("usr")
    
    # position relative to the plot height
    plot_height <- usr[4] - usr[3]
    y_bottom <- usr[3] - 0.02 * plot_height  # adjust clearance below plot
    y_tick_length <- 0.03 * plot_height      # Length of tick marks
    
    # Use a fixed distance below the ticks rather than relative to the plot
    text_y_pos <- y_bottom - 0.08 * plot_height  
    
    # Draw segments for tick marks
    for (i in 1:length(tick_positions)) {
      segments(
        x0 = tick_positions[i], 
        y0 = y_bottom, 
        x1 = tick_positions[i], 
        y1 = y_bottom + y_tick_length, 
        lwd = 1.2
      )
    }
    
    # Add text labels
    for (i in 1:length(tick_positions)) {
      text(
        x = tick_positions[i], 
        y = text_y_pos, 
        labels = tick_labels[i],
        cex = 0.5,
        adj = c(0.5, 1),
        font = 2
      )
    }
    
    par(xpd = FALSE)
  }
  
  # Helper function to position a grid plot in its quadrant
  position_grid_plot <- function(quadrant) {
    # Define the dimensions for each quadrant
    # Format: c(left, right, bottom, top)
    quadrant_dims <- list(
      "1" = c(0.0, 0.5, 0.5, 1.0),  # Top-left
      "2" = c(0.5, 1.0, 0.5, 1.0),  # Top-right
      "3" = c(0.0, 0.5, 0.0, 0.5),  # Bottom-left
      "4" = c(0.5, 1.0, 0.0, 0.5)   # Bottom-right
    )
    
    # Set the figure region for this quadrant
    par(fig = quadrant_dims[[as.character(quadrant)]], mar = c(4, 4, 3, 2))
    
    # Only use new=TRUE for quadrants after the first
    if (quadrant > 1) {
      par(new = TRUE)
    }
  }
  
  # Helper function to position a histogram inset in each plot
  position_histogram_inset <- function(quadrant) {
    # Define the base inset dimensions
    inset_width <- 0.165
    inset_height <- 0.32  # increase to provide space for labels
    
    # Base coordinates for each quadrant
    base_coords <- list(
      "1" = c(0.0, 0.5, 0.5, 1.0),  # Top-left quadrant
      "2" = c(0.5, 1.0, 0.5, 1.0),  # Top-right quadrant
      "3" = c(0.0, 0.5, 0.0, 0.5),  # Bottom-left quadrant
      "4" = c(0.5, 1.0, 0.0, 0.5)   # Bottom-right quadrant
    )
    
    # Get base coordinates for this quadrant
    base <- base_coords[[as.character(quadrant)]]
    
    # Position the inset in the upper-left corner
    inset_coords <- c(
      base[1] + 0.04,                # increase to move right
      base[1] + 0.12 + inset_width,  # match left edge
      base[3] + (base[4] - base[3]) * 0.58,  # lower shifts down
      base[4] - 0.08                 # smaller values = taller plot
    )
    
    par(fig = inset_coords, new = TRUE, mar = c(1.5, 0.1, 0.1, 0.1))
  }
  
  # Process each summary statistic
  for (stat_name in names(summary_stats)) {

    if (!grepl("_mean_precipitation$|_difference$|_bias_factor$", stat_name)) {
      next
    }
    
    base_stat_type <- gsub("_mean_precipitation$|_difference$|_bias_factor$", "", stat_name)
    
    stat_title <- switch(base_stat_type,
                         "min" = "Minimum",
                         "q1" = "First Quartile",
                         "median" = "Median",
                         "q3" = "Third Quartile",
                         "max" = "Maximum",
                         "mean" = "Mean",
                         "sd" = "Standard Dev.",
                         base_stat_type)
    
    observed_data <- results$observed_mean_precipitation
    
    mean_precip_stat_name <- paste0(base_stat_type, "_mean_precipitation")
    difference_stat_name <- paste0(base_stat_type, "_difference")
    bias_factor_stat_name <- paste0(base_stat_type, "_bias_factor")
    
    mean_precip_data <- summary_stats[[mean_precip_stat_name]]
    difference_data <- summary_stats[[difference_stat_name]]
    bias_factor_data <- summary_stats[[bias_factor_stat_name]]
    
    output_filename <- paste0("figures/mean_precipitation_summary_stats/mean_precipitation_", base_stat_type, "_summary_stats.jpg")
    jpeg(output_filename, width = 10, height = 8, units = "in", res = 300)
    
    # 1. Observed Mean Precipitation grid (Quadrant 1: Top-left)
    position_grid_plot(1)
    aggregate_plot_visualizer(
      observed_data, 
      paste0("Observed Mean Precipitation"),
      min_max_range = c(mean_min, mean_max)
    )
    
    # Add inset histogram for observed data
    observed_flat <- as.vector(observed_data)
    observed_flat <- observed_flat[!is.na(observed_flat)]
    position_histogram_inset(1)
    
    hist(observed_flat, 
         main = "", 
         xlab = "", 
         ylab = "",
         col = "lightblue", 
         border = "black",
         xlim = c(mean_min, mean_max),
         breaks = 20,
         axes = FALSE)
    
    create_custom_histogram_axis(mean_min, mean_max, plot_type = "mean_precip")
    
    # 2. Model Mean Precipitation Statistic grid (Quadrant 2: Top-right)
    position_grid_plot(2)
    aggregate_plot_visualizer(
      mean_precip_data, 
      paste0(stat_title, " of Model Mean Precip."),
      min_max_range = c(mean_min, mean_max)
    )
    
    # Add inset histogram for model data
    model_flat <- as.vector(mean_precip_data)
    model_flat <- model_flat[!is.na(model_flat)]
    position_histogram_inset(2)
    
    hist(model_flat, 
         main = "", 
         xlab = "", 
         ylab = "",
         col = "lightblue", 
         border = "black",
         xlim = c(mean_min, mean_max),
         breaks = 20,
         axes = FALSE)
    
    create_custom_histogram_axis(mean_min, mean_max, plot_type = "mean_precip")
    
    # 3. Normalized difference statistic grid (Quadrant 3: Bottom-left)
    position_grid_plot(3)
    difference_visualizer(
      difference_data, 
      paste0(stat_title, " of Normalized Difference"),
      min_max_range = c(diff_min, diff_max)
    )
    
    # Add inset histogram for difference data
    diff_flat <- as.vector(difference_data)
    diff_flat <- diff_flat[!is.na(diff_flat)]
    position_histogram_inset(3)
    
    hist(diff_flat, 
         main = "", 
         xlab = "", 
         ylab = "",
         col = "lightblue",
         border = "black",
         xlim = c(diff_min, diff_max),
         breaks = 20,
         axes = FALSE)
    
    create_custom_histogram_axis(diff_min, diff_max, plot_type = "difference")
    
    # 4. Bias factor statistic grid (Quadrant 4: Bottom-right)
    position_grid_plot(4)
    bias_factor_visualizer(
      bias_factor_data, 
      paste0(stat_title, " of Bias Factor"),
      min_max_range = c(bias_min, bias_max)
    )
    
    # Add inset histogram for bias factor data
    bias_flat <- as.vector(bias_factor_data)
    bias_flat <- bias_flat[!is.na(bias_flat)]
    position_histogram_inset(4)
    
    hist(bias_flat, 
         main = "", 
         xlab = "", 
         ylab = "",
         col = "lightblue",
         border = "black",
         xlim = c(bias_min, bias_max),
         breaks = 20,
         axes = FALSE)
    
    create_custom_histogram_axis(bias_min, bias_max, plot_type = "bias")
    
    dev.off()
    cat("Saved visualization for", stat_title, "to", output_filename, "\n")
  }
}

##################################
# MAIN EXECUTION

load("rdata/total_mean_precipitation_matrices_list.RData")

# Calculate all summary statistics and combine into a single list
summary_stats <- c(
  calculate_min(mean_derived_matrices),
  calculate_q1(mean_derived_matrices),
  calculate_median(mean_derived_matrices),
  calculate_q3(mean_derived_matrices),
  calculate_max(mean_derived_matrices),
  calculate_mean(mean_derived_matrices),
  calculate_sd(mean_derived_matrices)
)

create_summary_stat_plots_with_histograms(mean_derived_matrices, summary_stats)
